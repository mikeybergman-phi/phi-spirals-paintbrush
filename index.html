<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Golden Spiral Springs – Residue Zoom Visualizer</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  * { box-sizing: border-box; }
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    overflow: hidden;
    background: #050712;
    color: #e8eefc;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  }
  canvas { display: block; }

  #ui {
    position: fixed;
    right: 16px;
    top: 16px;
    width: 380px;
    max-height: calc(100% - 32px);
    overflow-y: auto;
    padding: 12px 14px 14px;
    background: rgba(8,12,30,0.92);
    border-radius: 12px;
    box-shadow: 0 14px 40px rgba(0,0,0,0.6);
    border: 1px solid rgba(120,150,255,0.3);
    backdrop-filter: blur(14px);
  }
  #ui h1 {
    font-size: 18px;
    margin: 0 0 6px;
    letter-spacing: 0.06em;
    text-transform: uppercase;
    color: #b9c8ff;
  }
  #ui small {
    display: block;
    margin-bottom: 10px;
    font-size: 11px;
    color: #8089b8;
  }
  .tagline {
    font-size: 11px;
    color: #939fd0;
    margin-bottom: 10px;
  }
  .row {
    margin-bottom: 8px;
  }
  .row label {
    font-size: 12px;
    display: flex;
    justify-content: space-between;
    margin-bottom: 2px;
    color: #d4ddff;
  }
  .row label span.value {
    color: #7fd2ff;
    font-variant-numeric: tabular-nums;
  }
  input[type="range"] {
    width: 100%;
  }
  input[type="checkbox"] {
    margin-right: 6px;
  }
  #showBaseLabel,
  #freezeColorLabel {
    font-size: 12px;
    color: #d4ddff;
    display: flex;
    align-items: center;
  }
  .hint {
    margin-top: 8px;
    font-size: 11px;
    color: #7c88b5;
    line-height: 1.4;
  }
  #audioControls {
    margin-top: 10px;
    padding-top: 8px;
    border-top: 1px solid rgba(120,150,255,0.3);
  }
  #audioFile {
    width: 100%;
    font-size: 11px;
    margin-bottom: 4px;
  }
  #audio {
    width: 100%;
    margin-top: 4px;
  }
  button {
    margin-top: 4px;
    padding: 4px 8px;
    font-size: 11px;
    border-radius: 999px;
    border: 1px solid rgba(150,190,255,0.7);
    background: radial-gradient(circle at 0 0,#253a6f,#10152c 60%,#070914);
    color: #dfe7ff;
    cursor: pointer;
  }
  button:hover { border-color: #ffffff; }

  #controlsRow {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 6px;
  }
  #zoomLabel {
    font-size: 11px;
    color: #9fb4ff;
    margin-top: 6px;
  }

  #toggleUiBtn {
    position: fixed;
    left: 12px;
    top: 12px;
    z-index: 1000;
    padding: 4px 10px;
    font-size: 11px;
    border-radius: 999px;
    border: 1px solid rgba(150,190,255,0.7);
    background: radial-gradient(circle at 0 0,#243566,#070914 65%);
    color: #dfe7ff;
    cursor: pointer;
  }
  #toggleUiBtn:hover {
    border-color: #ffffff;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<button id="toggleUiBtn">Hide UI</button>

<div id="ui">
  <h1>Golden Spiral Springs</h1>
  <div class="tagline">
    Whole φ spring cycling through the spectrum, residue building forever, zoom breathing with the bass.
  </div>
  <small>
    Drag to pan · Scroll to set zoom baseline · Music modulates zoom on top ·
    Trails never clear (unless you hit Clear)
  </small>

  <div class="row">
    <label>Turns <span class="value" id="turnsVal"></span></label>
    <input type="range" id="turns" min="1" max="10" step="0.1" value="4">
  </div>

  <div class="row">
    <label>Coils per Turn <span class="value" id="coilsVal"></span></label>
    <input type="range" id="coilsPerTurn" min="0" max="40" step="0.5" value="12">
  </div>

  <div class="row">
    <label>Spring Amplitude <span class="value" id="ampVal"></span></label>
    <input type="range" id="amplitude" min="0" max="80" step="1" value="22">
  </div>

  <div class="row">
    <label>Base Radius <span class="value" id="radVal"></span></label>
    <input type="range" id="baseRadius" min="10" max="120" step="1" value="40">
  </div>

  <div class="row">
    <label>Line Width <span class="value" id="lwVal"></span></label>
    <input type="range" id="lineWidth" min="0.5" max="4" step="0.1" value="1.8">
  </div>

  <div class="row">
    <label id="showBaseLabel">
      <input type="checkbox" id="showBase" checked>
      Show base golden spiral (faint)
    </label>
  </div>

  <div class="row">
    <label id="freezeColorLabel">
      <input type="checkbox" id="freezeColor">
      Freeze color (no hue rotation)
    </label>
  </div>

  <div id="audioControls">
    <div style="font-size:12px;color:#d4ddff;margin-bottom:4px;">Audio Input</div>
    <input type="file" id="audioFile" accept="audio/*">
    <audio id="audio" controls></audio>
    <button id="enableReactive">Enable Audio Reactive Mode</button>
    <div id="reactiveStatus">Status: visualizer idle (no audio hooked yet)</div>

    <div id="controlsRow">
      <button id="clearBtn">Clear Trails</button>
      <button id="captureBtn">Capture Image</button>
      <button id="recordBtn">Start Recording</button>
    </div>
    <div id="zoomLabel">Zoom baseline: <span id="zoomVal">1.00×</span></div>
  </div>

  <div class="hint">
    Tips:<br>
    • Residue never fades; it just keeps **accumulating**.<br>
    • Scroll to find a zoom “layer”; the music ripples zoom around that.<br>
    • Toggle “Freeze color” when you find a hue you love and want the fossil to stay in that color family.
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // UI elements
  const uiPanel = document.getElementById("ui");
  const toggleUiBtn = document.getElementById("toggleUiBtn");

  const turnsEl = document.getElementById("turns");
  const coilsEl = document.getElementById("coilsPerTurn");
  const ampEl   = document.getElementById("amplitude");
  const radEl   = document.getElementById("baseRadius");
  const lwEl    = document.getElementById("lineWidth");
  const showBaseEl   = document.getElementById("showBase");
  const freezeColorEl = document.getElementById("freezeColor");

  const turnsVal = document.getElementById("turnsVal");
  const coilsVal = document.getElementById("coilsVal");
  const ampVal   = document.getElementById("ampVal");
  const radVal   = document.getElementById("radVal");
  const lwVal    = document.getElementById("lwVal");

  const audioFileEl = document.getElementById("audioFile");
  const audioEl     = document.getElementById("audio");
  const enableReactiveBtn = document.getElementById("enableReactive");
  const reactiveStatus    = document.getElementById("reactiveStatus");

  const clearBtn   = document.getElementById("clearBtn");
  const captureBtn = document.getElementById("captureBtn");
  const recordBtn  = document.getElementById("recordBtn");
  const zoomValEl  = document.getElementById("zoomVal");

  // Toggle UI visibility
  toggleUiBtn.addEventListener("click", () => {
    if (uiPanel.style.display === "none") {
      uiPanel.style.display = "";
      toggleUiBtn.textContent = "Hide UI";
    } else {
      uiPanel.style.display = "none";
      toggleUiBtn.textContent = "Show UI";
    }
  });

  // Pan & zoom
  let offsetX = 0, offsetY = 0;
  let baseZoom = 1;
  let zoom = 1;
  let isDragging = false, lastX = 0, lastY = 0;

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width  = window.innerWidth  * dpr;
    canvas.height = window.innerHeight * dpr;
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.fillStyle = "#050712";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  }
  window.addEventListener("resize", resize);

  canvas.addEventListener("mousedown", e => {
    isDragging = true;
    lastX = e.clientX;
    lastY = e.clientY;
  });
  window.addEventListener("mouseup", () => { isDragging = false; });
  window.addEventListener("mousemove", e => {
    if (!isDragging) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX;
    lastY = e.clientY;
    offsetX += dx;
    offsetY += dy;
  });

  canvas.addEventListener("wheel", e => {
    e.preventDefault();
    const factor = Math.exp(-e.deltaY * 0.001);
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    const oldZoom = zoom;
    baseZoom *= factor;
    baseZoom = Math.max(0.1, Math.min(baseZoom, 10));

    const w = canvas.width  / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);

    const wx = (cx - w/2 - offsetX) / oldZoom;
    const wy = (cy - h/2 - offsetY) / oldZoom;

    zoom = baseZoom;

    const nx = wx * zoom + w/2 + offsetX;
    const ny = wy * zoom + h/2 + offsetY;

    offsetX += cx - nx;
    offsetY += cy - ny;

    zoomValEl.textContent = baseZoom.toFixed(2) + "×";
  }, { passive: false });

  clearBtn.addEventListener("click", () => {
    const w = canvas.width  / (window.devicePixelRatio || 1);
    const h = canvas.height / (window.devicePixelRatio || 1);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.clearRect(0,0,w,h);
    ctx.fillStyle = "#050712";
    ctx.fillRect(0,0,w,h);
  });

  // Capture image
  captureBtn.addEventListener("click", () => {
    const link = document.createElement("a");
    link.download = "golden_spiral_springs_" + Date.now() + ".png";
    link.href = canvas.toDataURL("image/png");
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  });

  // Video recording
  let mediaRecorder = null;
  let recordedChunks = [];
  let recording = false;

  recordBtn.addEventListener("click", () => {
    if (!recording) {
      startRecording();
    } else {
      stopRecording();
    }
  });

  function startRecording() {
    if (!("MediaRecorder" in window)) {
      alert("MediaRecorder not supported in this browser.");
      return;
    }
    const fps = 30;
    const stream = canvas.captureStream(fps);
    recordedChunks = [];
    try {
      mediaRecorder = new MediaRecorder(stream, { mimeType: "video/webm;codecs=vp9" });
    } catch (e) {
      mediaRecorder = new MediaRecorder(stream);
    }
    mediaRecorder.ondataavailable = e => {
      if (e.data.size > 0) recordedChunks.push(e.data);
    };
    mediaRecorder.onstop = () => {
      const blob = new Blob(recordedChunks, { type: "video/webm" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.style.display = "none";
      a.href = url;
      a.download = "golden_spiral_springs_capture_" + Date.now() + ".webm";
      document.body.appendChild(a);
      a.click();
      URL.revokeObjectURL(url);
      document.body.removeChild(a);
    };
    mediaRecorder.start();
    recording = true;
    recordBtn.textContent = "Stop Recording";
  }

  function stopRecording() {
    if (mediaRecorder && recording) {
      mediaRecorder.stop();
      recording = false;
      recordBtn.textContent = "Start Recording";
    }
  }

  // Baseline values from sliders
  const base = {
    turns:        parseFloat(turnsEl.value),
    coilsPerTurn: parseFloat(coilsEl.value),
    amplitude:    parseFloat(ampEl.value),
    baseRadius:   parseFloat(radEl.value),
    lineWidth:    parseFloat(lwEl.value)
  };

  function updateBaseFromSliders() {
    base.turns        = parseFloat(turnsEl.value)        || base.turns;
    base.coilsPerTurn = parseFloat(coilsEl.value)        || base.coilsPerTurn;
    base.amplitude    = parseFloat(ampEl.value)          || base.amplitude;
    base.baseRadius   = parseFloat(radEl.value)          || base.baseRadius;
    base.lineWidth    = parseFloat(lwEl.value)           || base.lineWidth;
  }

  function setLabelsFromDynamic(dyn) {
    turnsVal.textContent = dyn.turns.toFixed(1);
    coilsVal.textContent = dyn.coilsPerTurn.toFixed(1);
    ampVal.textContent   = dyn.amplitude.toFixed(0);
    radVal.textContent   = dyn.baseRadius.toFixed(0);
    lwVal.textContent    = dyn.lineWidth.toFixed(1);
  }

  [turnsEl, coilsEl, ampEl, radEl, lwEl].forEach(el => {
    el.addEventListener("input", () => {
      updateBaseFromSliders();
    });
  });

  // AUDIO
  let audioCtx = null;
  let analyser = null;
  let freqData = null;
  let sourceNode = null;
  let audioReactive = false;

  audioFileEl.addEventListener("change", () => {
    const file = audioFileEl.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    audioEl.src = url;
    audioEl.play().catch(() => {});
  });

  enableReactiveBtn.addEventListener("click", async () => {
    try {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      await audioCtx.resume();

      if (!sourceNode) {
        sourceNode = audioCtx.createMediaElementSource(audioEl);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        freqData = new Uint8Array(analyser.frequencyBinCount);
        sourceNode.connect(analyser);
        analyser.connect(audioCtx.destination);
      }

      audioReactive = true;
      reactiveStatus.textContent = "Status: audio reactive mode ON (sliders + zoom live)";
      reactiveStatus.style.color = "#7fd2ff";
    } catch (err) {
      reactiveStatus.textContent = "Status: error enabling audio (" + err.message + ")";
      reactiveStatus.style.color = "#ff8080";
    }
  });

  // Band state + hue control
  function clamp(v, min, max) {
    return v < min ? min : (v > max ? max : v);
  }

  let subSmooth = 0,
      bassSmooth = 0,
      lowMidSmooth = 0,
      highMidSmooth = 0,
      trebleSmooth = 0,
      overallSmooth = 0;

  let hueOffset = 0;
  let freezeColor = false;

  freezeColorEl.addEventListener("change", () => {
    freezeColor = freezeColorEl.checked;
    // When toggled on, hueOffset just stays where it is.
  });

  function sampleBands() {
    if (!audioReactive || !analyser || !freqData) {
      const decay = 0.1;
      subSmooth     *= (1 - decay);
      bassSmooth    *= (1 - decay);
      lowMidSmooth  *= (1 - decay);
      highMidSmooth *= (1 - decay);
      trebleSmooth  *= (1 - decay);
      overallSmooth *= (1 - decay);
      return;
    }

    analyser.getByteFrequencyData(freqData);
    const n = freqData.length;
    if (!n) return;

    const bandSize = Math.floor(n / 5);
    const bandAvg = (start, end) => {
      let sum = 0, count = 0;
      for (let i = start; i < end && i < n; i++) { sum += freqData[i]; count++; }
      return count ? sum / count : 0;
    };

    const subAvg     = bandAvg(0, bandSize);
    const bassAvg    = bandAvg(bandSize, bandSize*2);
    const lowMidAvg  = bandAvg(bandSize*2, bandSize*3);
    const highMidAvg = bandAvg(bandSize*3, bandSize*4);
    const trebleAvg  = bandAvg(bandSize*4, n);

    let allSum = 0;
    for (let i = 0; i < n; i++) allSum += freqData[i];
    const allAvg = allSum / n;

    const sF = 0.22;
    const norm = v => v / 255;

    subSmooth     += (norm(subAvg)     - subSmooth)     * sF;
    bassSmooth    += (norm(bassAvg)    - bassSmooth)    * sF;
    lowMidSmooth  += (norm(lowMidAvg)  - lowMidSmooth)  * sF;
    highMidSmooth += (norm(highMidAvg) - highMidSmooth) * sF;
    trebleSmooth  += (norm(trebleAvg)  - trebleSmooth)  * sF;
    overallSmooth += (norm(allAvg)     - overallSmooth) * sF;

    if (!freezeColor) {
      hueOffset = (hueOffset + trebleSmooth * 12 + overallSmooth * 4) % 360;
    }
  }

  // Dynamic params
  function computeDynamicParams(time) {
    const fTurns  = 0.7;
    const fCoils  = 1.3;
    const fAmp    = 0.9;
    const fRad    = 0.6;
    const fWidth  = 1.8;

    const spanTurns  = 3.0;
    const spanCoils  = 20.0;
    const spanAmp    = 40.0;
    const spanRad    = 60.0;
    const spanWidth  = 2.2;

    const subBass = (subSmooth + bassSmooth) * 0.5;

    const turns = clamp(
      base.turns + spanTurns * subBass * Math.sin(2 * Math.PI * fTurns * time),
      parseFloat(turnsEl.min), parseFloat(turnsEl.max)
    );

    const coilsPerTurn = clamp(
      base.coilsPerTurn + spanCoils * highMidSmooth * Math.sin(2 * Math.PI * fCoils * time + 1.1),
      parseFloat(coilsEl.min), parseFloat(coilsEl.max)
    );

    const amplitude = clamp(
      base.amplitude + spanAmp * lowMidSmooth * Math.sin(2 * Math.PI * fAmp * time + 0.4),
      parseFloat(ampEl.min), parseFloat(ampEl.max)
    );

    const baseRadius = clamp(
      base.baseRadius + spanRad * subBass * Math.sin(2 * Math.PI * fRad * time + 2.3),
      parseFloat(radEl.min), parseFloat(radEl.max)
    );

    const lineWidth = clamp(
      base.lineWidth + spanWidth * (trebleSmooth + overallSmooth) * Math.sin(2 * Math.PI * fWidth * time + 0.8),
      parseFloat(lwEl.min), parseFloat(lwEl.max)
    );

    return { turns, coilsPerTurn, amplitude, baseRadius, lineWidth };
  }

  // Draw spring with residue (no clearing)
  function drawSpringResidue(params) {
    const { turns, coilsPerTurn, amplitude, baseRadius, lineWidth } = params;
    const w = window.innerWidth;
    const h = window.innerHeight;

    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.translate(w/2 + offsetX, h/2 + offsetY);

    const subBass = (subSmooth + bassSmooth) * 0.5;
    const zoomWave = 1 + 0.45 * subBass * Math.sin(2 * Math.PI * 0.35 * performance.now()/1000) + 0.3 * overallSmooth;
    const zoomAudioFactor = clamp(zoomWave, 0.5, 2.0);
    zoom = baseZoom * zoomAudioFactor;

    ctx.scale(zoom, zoom);

    const phi = (1 + Math.sqrt(5)) / 2;
    const b = (2 * Math.log(phi)) / Math.PI;
    const a = baseRadius;
    const thetaStart = 0;
    const thetaEnd   = turns * 2 * Math.PI;
    const steps = 2000;

    const glowStrength = 18 + overallSmooth * 30;
    ctx.shadowBlur  = glowStrength;
    ctx.shadowColor = `hsl(${(hueOffset + 30) % 360}, 85%, ${55 + overallSmooth*15}%)`;

    if (showBaseEl.checked) {
      ctx.beginPath();
      for (let i = 0; i <= steps; i++) {
        const t = thetaStart + (thetaEnd - thetaStart) * (i / steps);
        const r = a * Math.exp(b * t);
        const x = r * Math.cos(t);
        const y = r * Math.sin(t);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "rgba(130,160,255,0.2)";
      ctx.lineWidth = Math.max(lineWidth * 0.4, 0.3);
      ctx.stroke();
    }

    const springHue   = hueOffset % 360;
    const springSat   = 78;
    const springLight = 53 + overallSmooth * 10;
    ctx.strokeStyle   = `hsl(${springHue}, ${springSat}%, ${springLight}%)`;
    ctx.lineWidth     = lineWidth;

    ctx.beginPath();
    let first = true;
    for (let i = 0; i <= steps; i++) {
      const t = thetaStart + (thetaEnd - thetaStart) * (i / steps);
      const r = a * Math.exp(b * t);
      const x = r * Math.cos(t);
      const y = r * Math.sin(t);

      const dr_dt = b * r;
      const dx_dt = dr_dt * Math.cos(t) - r * Math.sin(t);
      const dy_dt = dr_dt * Math.sin(t) + r * Math.cos(t);
      const len = Math.hypot(dx_dt, dy_dt) || 1;
      const tx = dx_dt / len;
      const ty = dy_dt / len;
      const nx = -ty;
      const ny = tx;

      const coilFreq = coilsPerTurn * turns;
      const osc = coilsPerTurn === 0 ? 0 : Math.sin(t * coilFreq);
      const offset = amplitude * osc;

      const xs = x + nx * offset;
      const ys = y + ny * offset;

      if (first) { ctx.moveTo(xs, ys); first = false; }
      else ctx.lineTo(xs, ys);
    }
    ctx.stroke();

    ctx.restore();

    // HUD
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = "rgba(160,180,255,0.85)";
    ctx.font = "11px system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI'";
    ctx.textAlign = "left";
    ctx.fillText("Golden Spiral Springs – residue zoom visualizer", 12, 18);
    ctx.restore();
  }

  // Main loop
  let startTime = performance.now();
  function loop() {
    const now = performance.now();
    const t = (now - startTime) / 1000;

    sampleBands();
    const dyn = computeDynamicParams(t);

    // Sliders wave with dynamic values
    turnsEl.value = dyn.turns.toFixed(1);
    coilsEl.value = dyn.coilsPerTurn.toFixed(1);
    ampEl.value   = dyn.amplitude.toFixed(0);
    radEl.value   = dyn.baseRadius.toFixed(0);
    lwEl.value    = dyn.lineWidth.toFixed(1);
    setLabelsFromDynamic(dyn);

    drawSpringResidue(dyn);

    requestAnimationFrame(loop);
  }

  resize();
  zoomValEl.textContent = baseZoom.toFixed(2) + "×";
  loop();
})();
</script>
</body>
</html>


